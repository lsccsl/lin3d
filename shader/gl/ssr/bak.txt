
uniform float uni_step_max_len;    //最大采样距离
uniform int uni_first_step_count;  //大区间采样次数
uniform int uni_second_step_count; //细分区间采样次数


			void main()
			{
				float tex_dep = texture2D(uni_tex_view_depth, gl_TexCoord[0].st).x;
				vec4 tex_nml = texture2D(uni_tex_nml, gl_TexCoord[0].st);
				vec3 view_nml = tex_nml.xyz * 2.0 - 1.0;
				vec4 clr = texture2D(uni_tex_clr, gl_TexCoord[0].st);

				vec3 org_clr = texture2D(uni_tex_final, gl_TexCoord[0].st).xyz;

				if(0 == clr.a)
				{
					gl_FragColor.xyz = org_clr;
					return;
				}

				float view_dep;
				tex_dep_2_view_dep(tex_dep, uni_dep_range, view_dep);

				vec3 view_pos;
				get_pos_by_dep(view_dep, vary_proj_pos.xy, uni_tan_half_fov, uni_aspect, view_pos);
				
				vec3 view_dir = normalize(view_pos);
				view_nml = normalize(view_nml);

				//============== 开始处理 ================

			/*
				uint pix_pos[2];
				uint rand_v[2];

				pix_pos[0] = uint(gl_TexCoord[0].s * uni_screen_x_pix) ^ 1551u;
				pix_pos[1] = uint(gl_TexCoord[0].t * uni_screen_y_pix) ^ 1551u;
				ScrambleTEA(pix_pos, 3, rand_v); 

				float Roughness = 0.10;
			*/
				
				float step_first  = max(uni_step_max_len / uni_first_step_count,  1.0);	
				float step_second = max(step_first / uni_second_step_count, 0.5);

				vec3 final_clr = vec3(0,0,0);
				
				for(int ir = 0; ir < uni_sample_num; ir ++) {

			#if 0
					//随机扰动法线
					float E[2];
					Hammersley( uint(ir), uint(sample_num), rand_v, E );
					
					vec4 H;
					ImportanceSampleBlinn( E, Roughness, H);
					vec3 h_t = normalize(H.xyz);                      

					vec3 normal_tmp = TangentToWorld(h_t, view_nml);
					normal_tmp = normalize(normal_tmp);
					vec3 trace_dir = reflect(view_dir, normal_tmp);
			#else
					vec3 trace_dir = reflect(view_dir, view_nml);
			#endif

					trace_dir = normalize(trace_dir);
					
					vec3 trace_step = step_first * trace_dir;
					vec3 second_trace_step = step_second * trace_dir;

					vec3 trace_pos_start = view_pos + 0.1 * trace_dir;
					vec4 find_start_view = vec4(trace_pos_start, 1);
					vec4 find_start_proj = uni_proj_mtx * find_start_view;
					find_start_proj.z = find_start_view.z;

					vec4 find_end_view = vec4(trace_pos_start + trace_step, 1);
					vec4 find_end_proj = uni_proj_mtx * find_end_view;
					find_end_proj.z = find_end_view.z;
					vec4 find_step = find_end_proj - find_start_proj;
					
					vec4 second_find_end_view = vec4(trace_pos_start + second_trace_step, 1);
					vec4 second_find_end_proj = uni_proj_mtx * second_find_end_view;
					second_find_end_proj.z = second_find_end_view.z;			
					vec4 second_find_step = second_find_end_proj - find_start_proj;


					float cur_diff = 0;
					float last_diff = 0;
					float iloop = 0;

					vec4 current_step = find_start_proj;
					vec4 last_step    = find_start_proj;
					
					vec3 second_trace_pos_start = view_pos + 0.1 * trace_dir - trace_step;
					int second_step_count = uni_second_step_count;

					for(int i = 0; i <= uni_first_step_count; i ++){

						vec2 tmp_proj = current_step.xy / current_step.w;			
						vec2 tmp_uv = (tmp_proj) * 0.5 + 0.5;

						float dep_tmp = texture2D(uni_tex_view_depth, tmp_uv).x;
						float dep_tmp_real;
						tex_dep_2_view_dep(dep_tmp, uni_dep_range, dep_tmp_real);
						dep_tmp_real = -dep_tmp_real;

						last_diff = cur_diff;
						cur_diff = current_step.z - dep_tmp_real;
						
						if(cur_diff <= 0.0000) {

							vec4 second_find_start_proj = last_step;

							float second_cur_diff = 0;
							float second_last_diff = 0;

							vec4 second_current_step = second_find_start_proj;
							vec4 second_last_step    = second_find_start_proj;

							for(int j = 0; j <= second_step_count + 1; j ++){
							
								vec2 second_tmp_proj = second_current_step.xy / second_current_step.w;			
								vec2 second_tmp_uv = (second_tmp_proj) * 0.5 + 0.5;

								float second_dep_tmp = texture2D(uni_tex_view_depth, second_tmp_uv).x;
								float second_dep_tmp_real;
								tex_dep_2_view_dep(second_dep_tmp, uni_dep_range, second_dep_tmp_real);
								second_dep_tmp_real = -second_dep_tmp_real;

								second_last_diff = second_cur_diff;
								second_cur_diff = second_current_step.z - second_dep_tmp_real;
								
								if(second_cur_diff <= 0.0000) {
									if(second_last_diff >= 0.0000) {
										if(abs(second_cur_diff) < 6 && abs(second_last_diff) < 6)
										{
											float rate = abs(second_cur_diff)/(abs(second_cur_diff) + abs(second_last_diff));

											vec4 intersection_proj = (second_current_step - second_find_step * rate);
											intersection_proj = intersection_proj/intersection_proj.w;
											vec2 intersection_uv = intersection_proj * 0.5 + 0.5;

											float fade_edge = 0;
											if(abs(intersection_proj.y) < 1.0 && abs(intersection_proj.x) < 1.0)
												fade_edge = 1;

											float fade = fade_edge;

											final_clr += texture2D(uni_tex_final, intersection_uv).xyz * fade;
											break;
										} else {
										}
									} else {
									}
								}

								second_last_step = second_current_step;
								second_current_step += second_find_step;
							}
							
							break;
						}
						else{
						#if 0
							last_step = current_step;
							current_step += find_step;
							
							second_trace_pos_start += trace_step;
						#else
							last_step = current_step;
							second_trace_pos_start += trace_step;

							int scale = max((i - 20) * 2, 1);

							step_first = step_first * scale;
							trace_step = trace_step * scale;
							find_step = find_step * scale;
							second_step_count = second_step_count * scale;

							current_step += find_step;
							
						#endif
						}
					}	
				}	
				
				gl_FragColor.xyz = final_clr;//(final_clr / uni_sample_num) * 1;
				//gl_FragColor.xyz = (final_clr) * 0.8 + org_clr;	
			}

